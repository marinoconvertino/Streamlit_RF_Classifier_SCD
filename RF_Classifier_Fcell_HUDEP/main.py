# --- RF Classifier for Active/Inactive Classification for SCD Lead Finding --- #
#     based on 2.0x Fcell (HbF) in HUDEP2 cells
#
#     M.Convertino - DesignTx - May 6th, 2024
# ----------------------------------------------------------------------------- #


# --- CODE STRUCTURE --- # 
#
# project_directory/
# │
# ├── main_script.py
# └── utils/
#     └── rdkit_utils.py
#     └── model_read_utils.py
# └── models/
#     └── model_numbers file
#     └── pickle files
# ---------------------- #


# --- SOFTWARE AND LIBRARY VERSIONS --- #
# Anaconda 3
# Python 3.10.9
# RDKit 2022.09.5
# Streamlit 1.34.0
# Pandas 1.5.3
# Scikit-Learn 1.4.1.post1
# Numpy 1.24.2
# Scipy 1.13.0 
# Matplotlib 3.8.4
# Seaborn 0.13.2
# Python Base64 encoder
# ------------------------------------- #


# --- RUN INSTRUCTIONS --- #
# In the project directory run the app as it follows:
# $> streamlit run main.py --server.enableXsrfProtection false


# ------------------- #
# --- WEBAPP CODE --- #
# ------------------- #
# --- Import Libraries & Modules --- #
import time
import streamlit as st
import pandas as pd
import os
import pickle
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import seaborn as sns
from utils.rdkit_utils import add_molecule_column, generate_morgan_fps
from utils.models_read_utils import load_models
from utils.models_run_utils import extract_features, make_predictions, create_prediction_dataframe
from utils.download_utils import create_csv_download_link, save_seaborn_plot_as_png, create_png_download_link
# ----

# Title
st.title("UPLOAD NEW DESIGNS\n ###### Upload standard compound SMILES without counterions\n ###### Follow the schema shown here below")
st.image("utils/input_file_example.png") 

# Upload CSV file
uploaded_file = st.file_uploader("Upload CSV file", type=['csv'])

if uploaded_file is not None:
    try:
        # Read the CSV file
        df = pd.read_csv(uploaded_file)
        
        # Display the dataframe
        st.write('Uploaded CSV file:')
        st.write(df)
        
        # RDKit-based fingerprints generation
        add_molecule_column(df)
        df = generate_morgan_fps(df)
        #st.write(df)
        
        # Load models
        file = './models/model_numbers'
        numbers = []
        with open(file, 'r') as file:
            for line in file:
                numbers.append(int(line.strip()))
        #st.write("Predictions will be generated by consensus of models #:", numbers)
        
        folder_path = os.getcwd()
        models_folder = 'models'
        models_dict = load_models(os.path.join(folder_path, models_folder), numbers)
        #st.write(models_dict)
        
        # Extract features and put into a numpy vector
        X = extract_features(df)
        #st.write(len(X))
        Xn = X.to_numpy()
        #st.write(Xn)

        # Add a time bar before making predictions
        with st.empty():
            for percent_complete in range(100):
                time.sleep(0.01)
                st.progress(percent_complete + 1)


        # Make predictions
        if not X.empty:
            # Proceed with calculating predictions and probabilities
            model_predictions, model_probabilities = make_predictions(models_dict, Xn)
            # After obtaining model_probabilities dictionary
            prediction_df = create_prediction_dataframe(df, model_probabilities)
            
            # Write output table
            st.write("Models Predictions:", prediction_df)
            
            # Button to download the prediction dataframe as csv file
            csv_download_link = create_csv_download_link(prediction_df, "predicted_classification.csv", "Download Prediction DataFrame")
            st.markdown(csv_download_link, unsafe_allow_html=True)
            
            # Plotting Distribution of Probability Across Models
            # Reshape the data for plotting
            data = []

            for position in range(len(next(iter(model_probabilities.values())))):
                for model, probs in model_probabilities.items():
                    data.append({
                        'DT#': prediction_df['DT#'].iloc[position],  # Use DT# as label
                        'Model': model,
                        'Probability': probs[position],
                    })

            df1 = pd.DataFrame(data)
            
            # Plot specification    
            plt.clf()
            plt.figure(figsize=(10, 8))
            
            palette = ['red' if x < 0.3 else 'blue' for x in prediction_df['Average Predicted Probability']]
            plot = sns.boxplot(data=df1, y='DT#', x='Probability', orient='h', linewidth=1.5, palette=palette, hue='DT#', legend=False)
            #fig = sns.boxplot(data=df1, y='DT#', x='Probability', orient='h', linewidth=1.5, color='white')

            # Add dashed line at x=0.3, set x-axis limits and interval on x-axis
            plt.axvline(x=0.3, color='gray', linestyle='--')
            plt.xlim(-0.01, 1.01)
            plt.gca().xaxis.set_major_locator(ticker.MultipleLocator(0.1))
            plt.tight_layout()
                
            # Titles and labels
            plt.title('Distribution of Probabilities Across Models')
            plt.ylabel('Compound')
            plt.xlabel('Classification (Active if > 0.3)')

            # Show Plot
            st.pyplot(plot.get_figure())
            
            
            # Download the plot 
            # Save the Seaborn plot as a PNG file
            saved_filename = save_seaborn_plot_as_png(plot, "probability_distribution.png")
            # Create a download link for the saved PNG file
            png_download_link = create_png_download_link(saved_filename, "Download Seaborn Plot")
            # Display the download link
            st.markdown(png_download_link, unsafe_allow_html=True)
                
        else:
            st.write("List of Compound SMILES is empty")
   
       
    # exception in running all the code above if the initial CSV file cannot be read!            
    except Exception as e:
        st.error("An error occurred: {}".format(str(e)))
        